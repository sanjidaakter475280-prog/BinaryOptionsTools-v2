# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

from __future__ import annotations
import os
import sys
import ctypes
from dataclasses import dataclass
import enum
import struct
import contextlib
import datetime
import threading
import itertools
import traceback
import typing
import asyncio
import platform


# Used for default argument values
_DEFAULT = object() # type: typing.Any


class _UniffiRustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_uint64),
        ("len", ctypes.c_uint64),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def default():
        return _UniffiRustBuffer(0, 0, None)

    @staticmethod
    def alloc(size):
        return _uniffi_rust_call(_UniffiLib.ffi_binary_options_tools_uni_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return _uniffi_rust_call(_UniffiLib.ffi_binary_options_tools_uni_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return _uniffi_rust_call(_UniffiLib.ffi_binary_options_tools_uni_rustbuffer_free, self)

    def __str__(self):
        return "_UniffiRustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def alloc_with_builder(*args):
        """Context-manger to allocate a buffer using a _UniffiRustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = _UniffiRustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consume_with_stream(self):
        """Context-manager to consume a buffer using a _UniffiRustBufferStream.

        The _UniffiRustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = _UniffiRustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError(f"junk data left in buffer at end of consume_with_stream {s.remaining()}")
        finally:
            self.free()

    @contextlib.contextmanager
    def read_with_stream(self):
        """Context-manager to read a buffer using a _UniffiRustBufferStream.

        This is like consume_with_stream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `_UniffiRustBuffer` data.
        """
        s = _UniffiRustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError(f"junk data left in buffer at end of read_with_stream {s.remaining()}")

class _UniffiForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "_UniffiForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class _UniffiRustBufferStream:
    """
    Helper for structured reading of bytes from a _UniffiRustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def read_i8(self):
        return self._unpack_from(1, ">b")

    def read_u8(self):
        return self._unpack_from(1, ">B")

    def read_i16(self):
        return self._unpack_from(2, ">h")

    def read_u16(self):
        return self._unpack_from(2, ">H")

    def read_i32(self):
        return self._unpack_from(4, ">i")

    def read_u32(self):
        return self._unpack_from(4, ">I")

    def read_i64(self):
        return self._unpack_from(8, ">q")

    def read_u64(self):
        return self._unpack_from(8, ">Q")

    def read_float(self):
        v = self._unpack_from(4, ">f")
        return v

    def read_double(self):
        return self._unpack_from(8, ">d")

class _UniffiRustBufferBuilder:
    """
    Helper for structured writing of bytes into a _UniffiRustBuffer.
    """

    def __init__(self):
        self.rbuf = _UniffiRustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, num_bytes):
        if self.rbuf.len + num_bytes > self.rbuf.capacity:
            self.rbuf = _UniffiRustBuffer.reserve(self.rbuf, num_bytes)
        yield None
        self.rbuf.len += num_bytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write_i8(self, v):
        self._pack_into(1, ">b", v)

    def write_u8(self, v):
        self._pack_into(1, ">B", v)

    def write_i16(self, v):
        self._pack_into(2, ">h", v)

    def write_u16(self, v):
        self._pack_into(2, ">H", v)

    def write_i32(self, v):
        self._pack_into(4, ">i", v)

    def write_u32(self, v):
        self._pack_into(4, ">I", v)

    def write_i64(self, v):
        self._pack_into(8, ">q", v)

    def write_u64(self, v):
        self._pack_into(8, ">Q", v)

    def write_float(self, v):
        self._pack_into(4, ">f", v)

    def write_double(self, v):
        self._pack_into(8, ">d", v)

    def write_c_size_t(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t) , "@N", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class _UniffiRustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", _UniffiRustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_UNEXPECTED_ERROR = 2

    @staticmethod
    def default():
        return _UniffiRustCallStatus(code=_UniffiRustCallStatus.CALL_SUCCESS, error_buf=_UniffiRustBuffer.default())

    def __str__(self):
        if self.code == _UniffiRustCallStatus.CALL_SUCCESS:
            return "_UniffiRustCallStatus(CALL_SUCCESS)"
        elif self.code == _UniffiRustCallStatus.CALL_ERROR:
            return "_UniffiRustCallStatus(CALL_ERROR)"
        elif self.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
            return "_UniffiRustCallStatus(CALL_UNEXPECTED_ERROR)"
        else:
            return "_UniffiRustCallStatus(<invalid code>)"

def _uniffi_rust_call(fn, *args):
    # Call a rust function
    return _uniffi_rust_call_with_error(None, fn, *args)

def _uniffi_rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the _UniffiConverter for the error class that corresponds to the result.
    call_status = _UniffiRustCallStatus.default()

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    _uniffi_check_call_status(error_ffi_converter, call_status)
    return result

def _uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == _UniffiRustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == _UniffiRustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("_uniffi_rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
        # When the rust code sees a panic, it tries to construct a _UniffiRustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = _UniffiFfiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid _UniffiRustCallStatus code: {}".format(
            call_status.code))

def _uniffi_trait_interface_call(call_status, make_call, write_return_value):
    try:
        return write_return_value(make_call())
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiFfiConverterString.lower(repr(e))

def _uniffi_trait_interface_call_with_error(call_status, make_call, write_return_value, error_type, lower_error):
    try:
        try:
            return write_return_value(make_call())
        except error_type as e:
            call_status.code = _UniffiRustCallStatus.CALL_ERROR
            call_status.error_buf = lower_error(e)
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiFfiConverterString.lower(repr(e))
# Initial value and increment amount for handles. 
# These ensure that Python-generated handles always have the lowest bit set
_UNIFFI_HANDLEMAP_INITIAL = 1
_UNIFFI_HANDLEMAP_DELTA = 2

class _UniffiHandleMap:
    """
    A map where inserting, getting and removing data is synchronized with a lock.
    """

    def __init__(self):
        # type Handle = int
        self._map = {}  # type: Dict[Handle, Any]
        self._lock = threading.Lock()
        self._counter = _UNIFFI_HANDLEMAP_INITIAL

    def insert(self, obj):
        with self._lock:
            return self._insert(obj)

    """Low-level insert, this assumes `self._lock` is held."""
    def _insert(self, obj):
        handle = self._counter
        self._counter += _UNIFFI_HANDLEMAP_DELTA
        self._map[handle] = obj
        return handle

    def get(self, handle):
        try:
            with self._lock:
                return self._map[handle]
        except KeyError:
            raise InternalError(f"_UniffiHandleMap.get: Invalid handle {handle}")

    def clone(self, handle):
        try:
            with self._lock:
                obj = self._map[handle]
                return self._insert(obj)
        except KeyError:
            raise InternalError(f"_UniffiHandleMap.clone: Invalid handle {handle}")

    def remove(self, handle):
        try:
            with self._lock:
                return self._map.pop(handle)
        except KeyError:
            raise InternalError(f"_UniffiHandleMap.remove: Invalid handle: {handle}")

    def __len__(self):
        return len(self._map)
# Types conforming to `_UniffiConverterPrimitive` pass themselves directly over the FFI.
class _UniffiConverterPrimitive:
    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return value

class _UniffiConverterPrimitiveInt(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError("'{}' object cannot be interpreted as an integer".format(type(value).__name__))
        if not isinstance(value, int):
            raise TypeError("__index__ returned non-int (type {})".format(type(value).__name__))
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError("{} requires {} <= value < {}".format(cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX))

class _UniffiConverterPrimitiveFloat(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError("__float__ returned non-float (type {})".format(type(value).__name__))

# Helper class for wrapper types that will always go through a _UniffiRustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class _UniffiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consume_with_stream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code, and the FFI Function declarations.
# Define some ctypes FFI types that we use in the library

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
_UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_int8)

def _uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_uint64, return_type, _UniffiRustCallStatus)

def _uniffi_load_indirect():
    """
    This is how we find and load the dynamic library provided by the component.
    For now we just look it up by name.
    """
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    libname = libname.format("binary_options_tools_uni")
    path = os.path.join(os.path.dirname(__file__), libname)
    lib = ctypes.cdll.LoadLibrary(path)
    return lib

def _uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 30
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = lib.ffi_binary_options_tools_uni_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")

def _uniffi_check_api_checksums(lib):
    if lib.uniffi_binary_options_tools_uni_checksum_constructor_pocketoption_init() != 50054:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_binary_options_tools_uni_checksum_constructor_pocketoption_new() != 31315:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_binary_options_tools_uni_checksum_constructor_pocketoption_new_with_url() != 40992:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_assets() != 48493:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_balance() != 26020:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_buy() != 63032:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_clear_closed_deals() != 9178:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_create_raw_handler() != 34256:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_get_candles() != 23490:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_get_candles_advanced() != 27509:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_get_closed_deals() != 47785:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_get_opened_deals() != 27985:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_history() != 27093:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_is_demo() != 19411:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_payout() != 5344:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_reconnect() != 9220:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_result() != 594:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_result_with_timeout() != 56468:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_sell() != 61157:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_server_time() != 10589:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_shutdown() != 51452:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_subscribe() != 23382:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_trade() != 14619:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_unsubscribe() != 29837:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_binary_options_tools_uni_checksum_method_rawhandler_send_and_wait() != 12420:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_binary_options_tools_uni_checksum_method_rawhandler_send_binary() != 12514:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_binary_options_tools_uni_checksum_method_rawhandler_send_text() != 41075:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_binary_options_tools_uni_checksum_method_rawhandler_wait_next() != 65338:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_binary_options_tools_uni_checksum_method_subscriptionstream_next() != 13448:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_binary_options_tools_uni_checksum_constructor_validator_all() != 22652:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_binary_options_tools_uni_checksum_constructor_validator_any() != 239:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_binary_options_tools_uni_checksum_constructor_validator_contains() != 4008:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_binary_options_tools_uni_checksum_constructor_validator_ends_with() != 3462:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_binary_options_tools_uni_checksum_constructor_validator_ne() != 13897:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_binary_options_tools_uni_checksum_constructor_validator_new() != 49602:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_binary_options_tools_uni_checksum_constructor_validator_regex() != 42529:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_binary_options_tools_uni_checksum_constructor_validator_starts_with() != 32570:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_binary_options_tools_uni_checksum_method_validator_check() != 57297:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniffiLib = _uniffi_load_indirect()
_UniffiLib.ffi_binary_options_tools_uni_rustbuffer_alloc.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_binary_options_tools_uni_rustbuffer_alloc.restype = _UniffiRustBuffer
_UniffiLib.ffi_binary_options_tools_uni_rustbuffer_from_bytes.argtypes = (
    _UniffiForeignBytes,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_binary_options_tools_uni_rustbuffer_from_bytes.restype = _UniffiRustBuffer
_UniffiLib.ffi_binary_options_tools_uni_rustbuffer_free.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_binary_options_tools_uni_rustbuffer_free.restype = None
_UniffiLib.ffi_binary_options_tools_uni_rustbuffer_reserve.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_binary_options_tools_uni_rustbuffer_reserve.restype = _UniffiRustBuffer
_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_int8,
)
_UNIFFI_FOREIGN_FUTURE_DROPPED_CALLBACK = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
class _UniffiForeignFutureDroppedCallbackStruct(ctypes.Structure):
    _fields_ = [
        ("handle", ctypes.c_uint64),
        ("free", _UNIFFI_FOREIGN_FUTURE_DROPPED_CALLBACK),
    ]
_UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_u8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_u8.restype = None
_UniffiLib.ffi_binary_options_tools_uni_rust_future_cancel_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_cancel_u8.restype = None
_UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_u8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_u8.restype = ctypes.c_uint8
_UniffiLib.ffi_binary_options_tools_uni_rust_future_free_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_free_u8.restype = None
_UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_i8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_i8.restype = None
_UniffiLib.ffi_binary_options_tools_uni_rust_future_cancel_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_cancel_i8.restype = None
_UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_i8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_i8.restype = ctypes.c_int8
_UniffiLib.ffi_binary_options_tools_uni_rust_future_free_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_free_i8.restype = None
_UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_u16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_u16.restype = None
_UniffiLib.ffi_binary_options_tools_uni_rust_future_cancel_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_cancel_u16.restype = None
_UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_u16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_u16.restype = ctypes.c_uint16
_UniffiLib.ffi_binary_options_tools_uni_rust_future_free_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_free_u16.restype = None
_UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_i16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_i16.restype = None
_UniffiLib.ffi_binary_options_tools_uni_rust_future_cancel_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_cancel_i16.restype = None
_UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_i16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_i16.restype = ctypes.c_int16
_UniffiLib.ffi_binary_options_tools_uni_rust_future_free_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_free_i16.restype = None
_UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_u32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_u32.restype = None
_UniffiLib.ffi_binary_options_tools_uni_rust_future_cancel_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_cancel_u32.restype = None
_UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_u32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_u32.restype = ctypes.c_uint32
_UniffiLib.ffi_binary_options_tools_uni_rust_future_free_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_free_u32.restype = None
_UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_i32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_i32.restype = None
_UniffiLib.ffi_binary_options_tools_uni_rust_future_cancel_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_cancel_i32.restype = None
_UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_i32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_i32.restype = ctypes.c_int32
_UniffiLib.ffi_binary_options_tools_uni_rust_future_free_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_free_i32.restype = None
_UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_u64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_u64.restype = None
_UniffiLib.ffi_binary_options_tools_uni_rust_future_cancel_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_cancel_u64.restype = None
_UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_u64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_u64.restype = ctypes.c_uint64
_UniffiLib.ffi_binary_options_tools_uni_rust_future_free_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_free_u64.restype = None
_UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_i64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_i64.restype = None
_UniffiLib.ffi_binary_options_tools_uni_rust_future_cancel_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_cancel_i64.restype = None
_UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_i64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_i64.restype = ctypes.c_int64
_UniffiLib.ffi_binary_options_tools_uni_rust_future_free_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_free_i64.restype = None
_UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_f32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_f32.restype = None
_UniffiLib.ffi_binary_options_tools_uni_rust_future_cancel_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_cancel_f32.restype = None
_UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_f32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_f32.restype = ctypes.c_float
_UniffiLib.ffi_binary_options_tools_uni_rust_future_free_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_free_f32.restype = None
_UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_f64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_f64.restype = None
_UniffiLib.ffi_binary_options_tools_uni_rust_future_cancel_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_cancel_f64.restype = None
_UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_f64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_f64.restype = ctypes.c_double
_UniffiLib.ffi_binary_options_tools_uni_rust_future_free_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_free_f64.restype = None
_UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_rust_buffer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_rust_buffer.restype = None
_UniffiLib.ffi_binary_options_tools_uni_rust_future_cancel_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_cancel_rust_buffer.restype = None
_UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_rust_buffer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_rust_buffer.restype = _UniffiRustBuffer
_UniffiLib.ffi_binary_options_tools_uni_rust_future_free_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_free_rust_buffer.restype = None
_UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_void.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_void.restype = None
_UniffiLib.ffi_binary_options_tools_uni_rust_future_cancel_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_cancel_void.restype = None
_UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_void.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_void.restype = None
_UniffiLib.ffi_binary_options_tools_uni_rust_future_free_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_binary_options_tools_uni_rust_future_free_void.restype = None
_UniffiLib.uniffi_binary_options_tools_uni_fn_clone_pocketoption.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_clone_pocketoption.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_free_pocketoption.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_free_pocketoption.restype = None
_UniffiLib.uniffi_binary_options_tools_uni_fn_clone_rawhandler.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_clone_rawhandler.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_free_rawhandler.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_free_rawhandler.restype = None
_UniffiLib.uniffi_binary_options_tools_uni_fn_clone_subscriptionstream.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_clone_subscriptionstream.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_free_subscriptionstream.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_free_subscriptionstream.restype = None
_UniffiLib.uniffi_binary_options_tools_uni_fn_clone_validator.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_clone_validator.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_free_validator.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_free_validator.restype = None
_UniffiLib.uniffi_binary_options_tools_uni_fn_constructor_pocketoption_init.argtypes = (
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_constructor_pocketoption_init.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_constructor_pocketoption_new.argtypes = (
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_constructor_pocketoption_new.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_constructor_pocketoption_new_with_url.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_constructor_pocketoption_new_with_url.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_assets.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_assets.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_balance.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_balance.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_buy.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.c_uint32,
    ctypes.c_double,
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_buy.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_clear_closed_deals.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_clear_closed_deals.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_create_raw_handler.argtypes = (
    ctypes.c_uint64,
    ctypes.c_uint64,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_create_raw_handler.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_get_candles.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.c_int64,
    ctypes.c_int64,
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_get_candles.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_get_candles_advanced.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.c_int64,
    ctypes.c_int64,
    ctypes.c_int64,
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_get_candles_advanced.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_get_closed_deals.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_get_closed_deals.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_get_opened_deals.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_get_opened_deals.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_history.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.c_uint32,
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_history.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_is_demo.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_is_demo.restype = ctypes.c_int8
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_payout.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_payout.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_reconnect.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_reconnect.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_result.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_result.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_result_with_timeout.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.c_uint64,
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_result_with_timeout.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_sell.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.c_uint32,
    ctypes.c_double,
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_sell.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_server_time.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_server_time.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_shutdown.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_shutdown.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_subscribe.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.c_uint64,
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_subscribe.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_trade.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_uint32,
    ctypes.c_double,
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_trade.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_unsubscribe.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_unsubscribe.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_rawhandler_send_and_wait.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_rawhandler_send_and_wait.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_rawhandler_send_binary.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_rawhandler_send_binary.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_rawhandler_send_text.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_rawhandler_send_text.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_rawhandler_wait_next.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_rawhandler_wait_next.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_subscriptionstream_next.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_subscriptionstream_next.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_constructor_validator_all.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_constructor_validator_all.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_constructor_validator_any.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_constructor_validator_any.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_constructor_validator_contains.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_constructor_validator_contains.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_constructor_validator_ends_with.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_constructor_validator_ends_with.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_constructor_validator_ne.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_constructor_validator_ne.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_constructor_validator_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_constructor_validator_new.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_constructor_validator_regex.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_constructor_validator_regex.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_constructor_validator_starts_with.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_constructor_validator_starts_with.restype = ctypes.c_uint64
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_validator_check.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_binary_options_tools_uni_fn_method_validator_check.restype = ctypes.c_int8
_UniffiLib.ffi_binary_options_tools_uni_uniffi_contract_version.argtypes = (
)
_UniffiLib.ffi_binary_options_tools_uni_uniffi_contract_version.restype = ctypes.c_uint32
_UniffiLib.uniffi_binary_options_tools_uni_checksum_constructor_pocketoption_init.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_constructor_pocketoption_init.restype = ctypes.c_uint16
_UniffiLib.uniffi_binary_options_tools_uni_checksum_constructor_pocketoption_new.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_constructor_pocketoption_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_binary_options_tools_uni_checksum_constructor_pocketoption_new_with_url.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_constructor_pocketoption_new_with_url.restype = ctypes.c_uint16
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_assets.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_assets.restype = ctypes.c_uint16
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_balance.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_balance.restype = ctypes.c_uint16
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_buy.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_buy.restype = ctypes.c_uint16
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_clear_closed_deals.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_clear_closed_deals.restype = ctypes.c_uint16
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_create_raw_handler.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_create_raw_handler.restype = ctypes.c_uint16
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_get_candles.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_get_candles.restype = ctypes.c_uint16
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_get_candles_advanced.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_get_candles_advanced.restype = ctypes.c_uint16
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_get_closed_deals.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_get_closed_deals.restype = ctypes.c_uint16
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_get_opened_deals.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_get_opened_deals.restype = ctypes.c_uint16
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_history.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_history.restype = ctypes.c_uint16
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_is_demo.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_is_demo.restype = ctypes.c_uint16
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_payout.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_payout.restype = ctypes.c_uint16
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_reconnect.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_reconnect.restype = ctypes.c_uint16
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_result.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_result.restype = ctypes.c_uint16
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_result_with_timeout.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_result_with_timeout.restype = ctypes.c_uint16
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_sell.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_sell.restype = ctypes.c_uint16
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_server_time.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_server_time.restype = ctypes.c_uint16
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_shutdown.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_shutdown.restype = ctypes.c_uint16
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_subscribe.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_subscribe.restype = ctypes.c_uint16
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_trade.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_trade.restype = ctypes.c_uint16
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_unsubscribe.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_unsubscribe.restype = ctypes.c_uint16
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_rawhandler_send_and_wait.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_rawhandler_send_and_wait.restype = ctypes.c_uint16
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_rawhandler_send_binary.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_rawhandler_send_binary.restype = ctypes.c_uint16
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_rawhandler_send_text.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_rawhandler_send_text.restype = ctypes.c_uint16
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_rawhandler_wait_next.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_rawhandler_wait_next.restype = ctypes.c_uint16
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_subscriptionstream_next.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_subscriptionstream_next.restype = ctypes.c_uint16
_UniffiLib.uniffi_binary_options_tools_uni_checksum_constructor_validator_all.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_constructor_validator_all.restype = ctypes.c_uint16
_UniffiLib.uniffi_binary_options_tools_uni_checksum_constructor_validator_any.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_constructor_validator_any.restype = ctypes.c_uint16
_UniffiLib.uniffi_binary_options_tools_uni_checksum_constructor_validator_contains.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_constructor_validator_contains.restype = ctypes.c_uint16
_UniffiLib.uniffi_binary_options_tools_uni_checksum_constructor_validator_ends_with.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_constructor_validator_ends_with.restype = ctypes.c_uint16
_UniffiLib.uniffi_binary_options_tools_uni_checksum_constructor_validator_ne.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_constructor_validator_ne.restype = ctypes.c_uint16
_UniffiLib.uniffi_binary_options_tools_uni_checksum_constructor_validator_new.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_constructor_validator_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_binary_options_tools_uni_checksum_constructor_validator_regex.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_constructor_validator_regex.restype = ctypes.c_uint16
_UniffiLib.uniffi_binary_options_tools_uni_checksum_constructor_validator_starts_with.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_constructor_validator_starts_with.restype = ctypes.c_uint16
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_validator_check.argtypes = (
)
_UniffiLib.uniffi_binary_options_tools_uni_checksum_method_validator_check.restype = ctypes.c_uint16

_uniffi_check_contract_api_version(_UniffiLib)
# _uniffi_check_api_checksums(_UniffiLib)

# RustFuturePoll values
_UNIFFI_RUST_FUTURE_POLL_READY = 0
_UNIFFI_RUST_FUTURE_POLL_WAKE = 1

# Stores futures for _uniffi_continuation_callback
_UniffiContinuationHandleMap = _UniffiHandleMap()

_UNIFFI_GLOBAL_EVENT_LOOP = None

"""
Set the event loop to use for async functions

This is needed if some async functions run outside of the eventloop, for example:
    - A non-eventloop thread is spawned, maybe from `EventLoop.run_in_executor` or maybe from the
      Rust code spawning its own thread.
    - The Rust code calls an async callback method from a sync callback function, using something
      like `pollster` to block on the async call.

In this case, we need an event loop to run the Python async function, but there's no eventloop set
for the thread.  Use `uniffi_set_event_loop` to force an eventloop to be used in this case.
"""
def uniffi_set_event_loop(eventloop: asyncio.BaseEventLoop):
    global _UNIFFI_GLOBAL_EVENT_LOOP
    _UNIFFI_GLOBAL_EVENT_LOOP = eventloop

def _uniffi_get_event_loop():
    if _UNIFFI_GLOBAL_EVENT_LOOP is not None:
        return _UNIFFI_GLOBAL_EVENT_LOOP
    else:
        return asyncio.get_running_loop()

# Continuation callback for async functions
# lift the return value or error and resolve the future, causing the async function to resume.
@_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK
def _uniffi_continuation_callback(future_ptr, poll_code):
    (eventloop, future) = _UniffiContinuationHandleMap.remove(future_ptr)
    eventloop.call_soon_threadsafe(_uniffi_set_future_result, future, poll_code)

def _uniffi_set_future_result(future, poll_code):
    if not future.cancelled():
        future.set_result(poll_code)

async def _uniffi_rust_call_async(rust_future, ffi_poll, ffi_complete, ffi_free, lift_func, error_ffi_converter):
    try:
        eventloop = _uniffi_get_event_loop()

        # Loop and poll until we see a _UNIFFI_RUST_FUTURE_POLL_READY value
        while True:
            future = eventloop.create_future()
            ffi_poll(
                rust_future,
                _uniffi_continuation_callback,
                _UniffiContinuationHandleMap.insert((eventloop, future)),
            )
            poll_code = await future
            if poll_code == _UNIFFI_RUST_FUTURE_POLL_READY:
                break

        return lift_func(
            _uniffi_rust_call_with_error(error_ffi_converter, ffi_complete, rust_future)
        )
    finally:
        ffi_free(rust_future)

# Public interface members begin here.


class _UniffiFfiConverterInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i32"
    VALUE_MIN = -2**31
    VALUE_MAX = 2**31

    @staticmethod
    def read(buf):
        return buf.read_i32()

    @staticmethod
    def write(value, buf):
        buf.write_i32(value)

class _UniffiFfiConverterString:
    @staticmethod
    def check_lower(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8_bytes = buf.read(size)
        return utf8_bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        utf8_bytes = value.encode("utf-8")
        buf.write_i32(len(utf8_bytes))
        buf.write(utf8_bytes)

    @staticmethod
    def lift(buf):
        with buf.consume_with_stream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()

class _UniffiFfiConverterBoolean:
    @classmethod
    def check_lower(cls, value):
        return not not value

    @classmethod
    def lower(cls, value):
        return 1 if value else 0

    @staticmethod
    def lift(value):
        return value != 0

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.read_u8())

    @classmethod
    def write(cls, value, buf):
        buf.write_u8(value)

class _UniffiFfiConverterUInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u32"
    VALUE_MIN = 0
    VALUE_MAX = 2**32

    @staticmethod
    def read(buf):
        return buf.read_u32()

    @staticmethod
    def write(value, buf):
        buf.write_u32(value)

@dataclass
class CandleLength:
    """
    Represents the duration of a candle.

    This struct is a simple wrapper around a `u32` that represents the candle duration in seconds.
    It is used in the `Asset` struct to specify the allowed candle lengths for an asset.

    # Examples

    ## Python
    ```python
    from binaryoptionstoolsuni import CandleLength

    five_second_candle = CandleLength(time=5)
    ```
"""
    def __init__(self, *, time:int):
        self.time = time
        
        

    
    def __str__(self):
        return "CandleLength(time={})".format(self.time)
    def __eq__(self, other):
        if self.time != other.time:
            return False
        return True

class _UniffiFfiConverterTypeCandleLength(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CandleLength(
            time=_UniffiFfiConverterUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterUInt32.check_lower(value.time)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterUInt32.write(value.time, buf)

class _UniffiFfiConverterSequenceTypeCandleLength(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeCandleLength.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeCandleLength.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeCandleLength.read(buf) for i in range(count)
        ]






class AssetType(enum.Enum):
    """
    Represents the type of an asset.

    This enum is used to categorize assets into different types, such as stocks, currencies, etc.
    This information can be useful for filtering and organizing assets.

    # Examples

    ## Python
    ```python
    from binaryoptionstoolsuni import AssetType

    asset_type = AssetType.CURRENCY
    ```
"""
    
    STOCK = 0
    
    CURRENCY = 1
    
    COMMODITY = 2
    
    CRYPTOCURRENCY = 3
    
    INDEX = 4
    


class _UniffiFfiConverterTypeAssetType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AssetType.STOCK
        if variant == 2:
            return AssetType.CURRENCY
        if variant == 3:
            return AssetType.COMMODITY
        if variant == 4:
            return AssetType.CRYPTOCURRENCY
        if variant == 5:
            return AssetType.INDEX
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == AssetType.STOCK:
            return
        if value == AssetType.CURRENCY:
            return
        if value == AssetType.COMMODITY:
            return
        if value == AssetType.CRYPTOCURRENCY:
            return
        if value == AssetType.INDEX:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == AssetType.STOCK:
            buf.write_i32(1)
        if value == AssetType.CURRENCY:
            buf.write_i32(2)
        if value == AssetType.COMMODITY:
            buf.write_i32(3)
        if value == AssetType.CRYPTOCURRENCY:
            buf.write_i32(4)
        if value == AssetType.INDEX:
            buf.write_i32(5)



@dataclass
class Asset:
    """
    Represents a financial asset that can be traded.

    This struct contains all the information about a specific asset, such as its name, symbol,
    payout, and whether it's currently active.

    # Examples

    ## Python
    ```python
    from binaryoptionstoolsuni import Asset

    # This is an example of how you might receive an Asset object
    # from the API. You would not typically construct this yourself.
    eurusd = Asset(id=1, name="EUR/USD", symbol="EURUSD_otc", is_otc=True, is_active=True, payout=85, allowed_candles=[], asset_type=AssetType.CURRENCY)
    print(eurusd.name)
    ```
"""
    def __init__(self, *, id:int, name:str, symbol:str, is_otc:bool, is_active:bool, payout:int, allowed_candles:typing.List[CandleLength], asset_type:AssetType):
        self.id = id
        self.name = name
        self.symbol = symbol
        self.is_otc = is_otc
        self.is_active = is_active
        self.payout = payout
        self.allowed_candles = allowed_candles
        self.asset_type = asset_type
        
        

    
    def __str__(self):
        return "Asset(id={}, name={}, symbol={}, is_otc={}, is_active={}, payout={}, allowed_candles={}, asset_type={})".format(self.id, self.name, self.symbol, self.is_otc, self.is_active, self.payout, self.allowed_candles, self.asset_type)
    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.name != other.name:
            return False
        if self.symbol != other.symbol:
            return False
        if self.is_otc != other.is_otc:
            return False
        if self.is_active != other.is_active:
            return False
        if self.payout != other.payout:
            return False
        if self.allowed_candles != other.allowed_candles:
            return False
        if self.asset_type != other.asset_type:
            return False
        return True

class _UniffiFfiConverterTypeAsset(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Asset(
            id=_UniffiFfiConverterInt32.read(buf),
            name=_UniffiFfiConverterString.read(buf),
            symbol=_UniffiFfiConverterString.read(buf),
            is_otc=_UniffiFfiConverterBoolean.read(buf),
            is_active=_UniffiFfiConverterBoolean.read(buf),
            payout=_UniffiFfiConverterInt32.read(buf),
            allowed_candles=_UniffiFfiConverterSequenceTypeCandleLength.read(buf),
            asset_type=_UniffiFfiConverterTypeAssetType.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterInt32.check_lower(value.id)
        _UniffiFfiConverterString.check_lower(value.name)
        _UniffiFfiConverterString.check_lower(value.symbol)
        _UniffiFfiConverterBoolean.check_lower(value.is_otc)
        _UniffiFfiConverterBoolean.check_lower(value.is_active)
        _UniffiFfiConverterInt32.check_lower(value.payout)
        _UniffiFfiConverterSequenceTypeCandleLength.check_lower(value.allowed_candles)
        _UniffiFfiConverterTypeAssetType.check_lower(value.asset_type)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterInt32.write(value.id, buf)
        _UniffiFfiConverterString.write(value.name, buf)
        _UniffiFfiConverterString.write(value.symbol, buf)
        _UniffiFfiConverterBoolean.write(value.is_otc, buf)
        _UniffiFfiConverterBoolean.write(value.is_active, buf)
        _UniffiFfiConverterInt32.write(value.payout, buf)
        _UniffiFfiConverterSequenceTypeCandleLength.write(value.allowed_candles, buf)
        _UniffiFfiConverterTypeAssetType.write(value.asset_type, buf)

class _UniffiFfiConverterInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i64"
    VALUE_MIN = -2**63
    VALUE_MAX = 2**63

    @staticmethod
    def read(buf):
        return buf.read_i64()

    @staticmethod
    def write(value, buf):
        buf.write_i64(value)

class _UniffiFfiConverterFloat64(_UniffiConverterPrimitiveFloat):
    @staticmethod
    def read(buf):
        return buf.read_double()

    @staticmethod
    def write(value, buf):
        buf.write_double(value)

class _UniffiFfiConverterOptionalFloat64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterFloat64.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterFloat64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterFloat64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

@dataclass
class Candle:
    """
    Represents a single candle in a price chart.

    A candle represents the price movement of an asset over a specific time period.
    It contains the open, high, low, and close (OHLC) prices for that period.

    # Examples

    ## Python
    ```python
    from binaryoptionstoolsuni import Candle

    # This is an example of how you might receive a Candle object
    # from the API.
    candle = ... # receive from api.get_candles() or stream.next()
    print(f"Candle for {candle.symbol} at {candle.timestamp}: O={candle.open}, H={candle.high}, L={candle.low}, C={candle.close}")
    ```
"""
    def __init__(self, *, symbol:str, timestamp:int, open:float, high:float, low:float, close:float, volume:typing.Optional[float]):
        self.symbol = symbol
        self.timestamp = timestamp
        self.open = open
        self.high = high
        self.low = low
        self.close = close
        self.volume = volume
        
        

    
    def __str__(self):
        return "Candle(symbol={}, timestamp={}, open={}, high={}, low={}, close={}, volume={})".format(self.symbol, self.timestamp, self.open, self.high, self.low, self.close, self.volume)
    def __eq__(self, other):
        if self.symbol != other.symbol:
            return False
        if self.timestamp != other.timestamp:
            return False
        if self.open != other.open:
            return False
        if self.high != other.high:
            return False
        if self.low != other.low:
            return False
        if self.close != other.close:
            return False
        if self.volume != other.volume:
            return False
        return True

class _UniffiFfiConverterTypeCandle(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Candle(
            symbol=_UniffiFfiConverterString.read(buf),
            timestamp=_UniffiFfiConverterInt64.read(buf),
            open=_UniffiFfiConverterFloat64.read(buf),
            high=_UniffiFfiConverterFloat64.read(buf),
            low=_UniffiFfiConverterFloat64.read(buf),
            close=_UniffiFfiConverterFloat64.read(buf),
            volume=_UniffiFfiConverterOptionalFloat64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.symbol)
        _UniffiFfiConverterInt64.check_lower(value.timestamp)
        _UniffiFfiConverterFloat64.check_lower(value.open)
        _UniffiFfiConverterFloat64.check_lower(value.high)
        _UniffiFfiConverterFloat64.check_lower(value.low)
        _UniffiFfiConverterFloat64.check_lower(value.close)
        _UniffiFfiConverterOptionalFloat64.check_lower(value.volume)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.symbol, buf)
        _UniffiFfiConverterInt64.write(value.timestamp, buf)
        _UniffiFfiConverterFloat64.write(value.open, buf)
        _UniffiFfiConverterFloat64.write(value.high, buf)
        _UniffiFfiConverterFloat64.write(value.low, buf)
        _UniffiFfiConverterFloat64.write(value.close, buf)
        _UniffiFfiConverterOptionalFloat64.write(value.volume, buf)

class _UniffiFfiConverterUInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u64"
    VALUE_MIN = 0
    VALUE_MAX = 2**64

    @staticmethod
    def read(buf):
        return buf.read_u64()

    @staticmethod
    def write(value, buf):
        buf.write_u64(value)

class _UniffiFfiConverterOptionalString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

class _UniffiFfiConverterOptionalInt32(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterInt32.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

class _UniffiFfiConverterOptionalBoolean(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterBoolean.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterBoolean.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterBoolean.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

@dataclass
class Deal:
    """
    Represents a completed trade.

    This struct contains all the information about a trade that has been opened and subsequently closed.
    It includes details such as the open and close prices, profit, and timestamps.

    # Examples

    ## Python
    ```python
    from binaryoptionstoolsuni import Deal

    # This is an example of how you might receive a Deal object
    # from the API after a trade is completed.
    # You would not typically construct this yourself.
    deal = ... # receive from api.result()
    print(f"Trade {deal.id} on {deal.asset} resulted in a profit of {deal.profit}")
    ```
"""
    def __init__(self, *, id:str, open_time:str, close_time:str, open_timestamp:int, close_timestamp:int, uid:int, request_id:typing.Optional[str], amount:float, profit:float, percent_profit:int, percent_loss:int, open_price:float, close_price:float, command:int, asset:str, is_demo:int, copy_ticket:str, open_ms:int, close_ms:typing.Optional[int], option_type:int, is_rollover:typing.Optional[bool], is_copy_signal:typing.Optional[bool], is_ai:typing.Optional[bool], currency:str, amount_usd:typing.Optional[float], amount_usd2:typing.Optional[float]):
        self.id = id
        self.open_time = open_time
        self.close_time = close_time
        self.open_timestamp = open_timestamp
        self.close_timestamp = close_timestamp
        self.uid = uid
        self.request_id = request_id
        self.amount = amount
        self.profit = profit
        self.percent_profit = percent_profit
        self.percent_loss = percent_loss
        self.open_price = open_price
        self.close_price = close_price
        self.command = command
        self.asset = asset
        self.is_demo = is_demo
        self.copy_ticket = copy_ticket
        self.open_ms = open_ms
        self.close_ms = close_ms
        self.option_type = option_type
        self.is_rollover = is_rollover
        self.is_copy_signal = is_copy_signal
        self.is_ai = is_ai
        self.currency = currency
        self.amount_usd = amount_usd
        self.amount_usd2 = amount_usd2
        
        

    
    def __str__(self):
        return "Deal(id={}, open_time={}, close_time={}, open_timestamp={}, close_timestamp={}, uid={}, request_id={}, amount={}, profit={}, percent_profit={}, percent_loss={}, open_price={}, close_price={}, command={}, asset={}, is_demo={}, copy_ticket={}, open_ms={}, close_ms={}, option_type={}, is_rollover={}, is_copy_signal={}, is_ai={}, currency={}, amount_usd={}, amount_usd2={})".format(self.id, self.open_time, self.close_time, self.open_timestamp, self.close_timestamp, self.uid, self.request_id, self.amount, self.profit, self.percent_profit, self.percent_loss, self.open_price, self.close_price, self.command, self.asset, self.is_demo, self.copy_ticket, self.open_ms, self.close_ms, self.option_type, self.is_rollover, self.is_copy_signal, self.is_ai, self.currency, self.amount_usd, self.amount_usd2)
    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.open_time != other.open_time:
            return False
        if self.close_time != other.close_time:
            return False
        if self.open_timestamp != other.open_timestamp:
            return False
        if self.close_timestamp != other.close_timestamp:
            return False
        if self.uid != other.uid:
            return False
        if self.request_id != other.request_id:
            return False
        if self.amount != other.amount:
            return False
        if self.profit != other.profit:
            return False
        if self.percent_profit != other.percent_profit:
            return False
        if self.percent_loss != other.percent_loss:
            return False
        if self.open_price != other.open_price:
            return False
        if self.close_price != other.close_price:
            return False
        if self.command != other.command:
            return False
        if self.asset != other.asset:
            return False
        if self.is_demo != other.is_demo:
            return False
        if self.copy_ticket != other.copy_ticket:
            return False
        if self.open_ms != other.open_ms:
            return False
        if self.close_ms != other.close_ms:
            return False
        if self.option_type != other.option_type:
            return False
        if self.is_rollover != other.is_rollover:
            return False
        if self.is_copy_signal != other.is_copy_signal:
            return False
        if self.is_ai != other.is_ai:
            return False
        if self.currency != other.currency:
            return False
        if self.amount_usd != other.amount_usd:
            return False
        if self.amount_usd2 != other.amount_usd2:
            return False
        return True

class _UniffiFfiConverterTypeDeal(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Deal(
            id=_UniffiFfiConverterString.read(buf),
            open_time=_UniffiFfiConverterString.read(buf),
            close_time=_UniffiFfiConverterString.read(buf),
            open_timestamp=_UniffiFfiConverterInt64.read(buf),
            close_timestamp=_UniffiFfiConverterInt64.read(buf),
            uid=_UniffiFfiConverterUInt64.read(buf),
            request_id=_UniffiFfiConverterOptionalString.read(buf),
            amount=_UniffiFfiConverterFloat64.read(buf),
            profit=_UniffiFfiConverterFloat64.read(buf),
            percent_profit=_UniffiFfiConverterInt32.read(buf),
            percent_loss=_UniffiFfiConverterInt32.read(buf),
            open_price=_UniffiFfiConverterFloat64.read(buf),
            close_price=_UniffiFfiConverterFloat64.read(buf),
            command=_UniffiFfiConverterInt32.read(buf),
            asset=_UniffiFfiConverterString.read(buf),
            is_demo=_UniffiFfiConverterUInt32.read(buf),
            copy_ticket=_UniffiFfiConverterString.read(buf),
            open_ms=_UniffiFfiConverterInt32.read(buf),
            close_ms=_UniffiFfiConverterOptionalInt32.read(buf),
            option_type=_UniffiFfiConverterInt32.read(buf),
            is_rollover=_UniffiFfiConverterOptionalBoolean.read(buf),
            is_copy_signal=_UniffiFfiConverterOptionalBoolean.read(buf),
            is_ai=_UniffiFfiConverterOptionalBoolean.read(buf),
            currency=_UniffiFfiConverterString.read(buf),
            amount_usd=_UniffiFfiConverterOptionalFloat64.read(buf),
            amount_usd2=_UniffiFfiConverterOptionalFloat64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.id)
        _UniffiFfiConverterString.check_lower(value.open_time)
        _UniffiFfiConverterString.check_lower(value.close_time)
        _UniffiFfiConverterInt64.check_lower(value.open_timestamp)
        _UniffiFfiConverterInt64.check_lower(value.close_timestamp)
        _UniffiFfiConverterUInt64.check_lower(value.uid)
        _UniffiFfiConverterOptionalString.check_lower(value.request_id)
        _UniffiFfiConverterFloat64.check_lower(value.amount)
        _UniffiFfiConverterFloat64.check_lower(value.profit)
        _UniffiFfiConverterInt32.check_lower(value.percent_profit)
        _UniffiFfiConverterInt32.check_lower(value.percent_loss)
        _UniffiFfiConverterFloat64.check_lower(value.open_price)
        _UniffiFfiConverterFloat64.check_lower(value.close_price)
        _UniffiFfiConverterInt32.check_lower(value.command)
        _UniffiFfiConverterString.check_lower(value.asset)
        _UniffiFfiConverterUInt32.check_lower(value.is_demo)
        _UniffiFfiConverterString.check_lower(value.copy_ticket)
        _UniffiFfiConverterInt32.check_lower(value.open_ms)
        _UniffiFfiConverterOptionalInt32.check_lower(value.close_ms)
        _UniffiFfiConverterInt32.check_lower(value.option_type)
        _UniffiFfiConverterOptionalBoolean.check_lower(value.is_rollover)
        _UniffiFfiConverterOptionalBoolean.check_lower(value.is_copy_signal)
        _UniffiFfiConverterOptionalBoolean.check_lower(value.is_ai)
        _UniffiFfiConverterString.check_lower(value.currency)
        _UniffiFfiConverterOptionalFloat64.check_lower(value.amount_usd)
        _UniffiFfiConverterOptionalFloat64.check_lower(value.amount_usd2)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.id, buf)
        _UniffiFfiConverterString.write(value.open_time, buf)
        _UniffiFfiConverterString.write(value.close_time, buf)
        _UniffiFfiConverterInt64.write(value.open_timestamp, buf)
        _UniffiFfiConverterInt64.write(value.close_timestamp, buf)
        _UniffiFfiConverterUInt64.write(value.uid, buf)
        _UniffiFfiConverterOptionalString.write(value.request_id, buf)
        _UniffiFfiConverterFloat64.write(value.amount, buf)
        _UniffiFfiConverterFloat64.write(value.profit, buf)
        _UniffiFfiConverterInt32.write(value.percent_profit, buf)
        _UniffiFfiConverterInt32.write(value.percent_loss, buf)
        _UniffiFfiConverterFloat64.write(value.open_price, buf)
        _UniffiFfiConverterFloat64.write(value.close_price, buf)
        _UniffiFfiConverterInt32.write(value.command, buf)
        _UniffiFfiConverterString.write(value.asset, buf)
        _UniffiFfiConverterUInt32.write(value.is_demo, buf)
        _UniffiFfiConverterString.write(value.copy_ticket, buf)
        _UniffiFfiConverterInt32.write(value.open_ms, buf)
        _UniffiFfiConverterOptionalInt32.write(value.close_ms, buf)
        _UniffiFfiConverterInt32.write(value.option_type, buf)
        _UniffiFfiConverterOptionalBoolean.write(value.is_rollover, buf)
        _UniffiFfiConverterOptionalBoolean.write(value.is_copy_signal, buf)
        _UniffiFfiConverterOptionalBoolean.write(value.is_ai, buf)
        _UniffiFfiConverterString.write(value.currency, buf)
        _UniffiFfiConverterOptionalFloat64.write(value.amount_usd, buf)
        _UniffiFfiConverterOptionalFloat64.write(value.amount_usd2, buf)






class Action(enum.Enum):
    """
    Represents the action to take in a trade.

    This enum is used to specify whether a trade is a "Call" (buy) or a "Put" (sell).
    It's a fundamental concept in binary options trading.

    # Examples

    ## Python
    ```python
    from binaryoptionstoolsuni import Action

    buy_action = Action.CALL
    sell_action = Action.PUT
    ```

    ## Swift
    ```swift
    import binaryoptionstoolsuni

    let buyAction = Action.call
    let sellAction = Action.put
    ```

    ## Kotlin
    ```kotlin
    import uniffi.binaryoptionstoolsuni.Action

    val buyAction = Action.CALL
    val sellAction = Action.PUT
    ```

    ## C#
    ```csharp
    using UniFFI.BinaryOptionsToolsUni;

    var buyAction = Action.Call;
    var sellAction = Action.Put;
    ```

    ## Go
    ```go
    import "github.com/your-repo/binaryoptionstoolsuni"

    var buyAction = binaryoptionstoolsuni.ActionCall
    var sellAction = binaryoptionstoolsuni.ActionPut
    ```
"""
    
    CALL = 0
    
    PUT = 1
    


class _UniffiFfiConverterTypeAction(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Action.CALL
        if variant == 2:
            return Action.PUT
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == Action.CALL:
            return
        if value == Action.PUT:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == Action.CALL:
            buf.write_i32(1)
        if value == Action.PUT:
            buf.write_i32(2)





# UniError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class UniError(Exception):
    pass

_UniffiTempUniError = UniError

class UniError:  # type: ignore
    
    class BinaryOptions(_UniffiTempUniError):
        
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "UniError.BinaryOptions({})".format(str(self))
    _UniffiTempUniError.BinaryOptions = BinaryOptions # type: ignore
    class PocketOption(_UniffiTempUniError):
        
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "UniError.PocketOption({})".format(str(self))
    _UniffiTempUniError.PocketOption = PocketOption # type: ignore
    class Uuid(_UniffiTempUniError):
        
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "UniError.Uuid({})".format(str(self))
    _UniffiTempUniError.Uuid = Uuid # type: ignore
    class Validator(_UniffiTempUniError):
        
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "UniError.Validator({})".format(str(self))
    _UniffiTempUniError.Validator = Validator # type: ignore

UniError = _UniffiTempUniError # type: ignore
del _UniffiTempUniError


class _UniffiFfiConverterTypeUniError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return UniError.BinaryOptions(
                _UniffiFfiConverterString.read(buf),
            )
        if variant == 2:
            return UniError.PocketOption(
                _UniffiFfiConverterString.read(buf),
            )
        if variant == 3:
            return UniError.Uuid(
                _UniffiFfiConverterString.read(buf),
            )
        if variant == 4:
            return UniError.Validator(
                _UniffiFfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, UniError.BinaryOptions):
            _UniffiFfiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, UniError.PocketOption):
            _UniffiFfiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, UniError.Uuid):
            _UniffiFfiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, UniError.Validator):
            _UniffiFfiConverterString.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, UniError.BinaryOptions):
            buf.write_i32(1)
            _UniffiFfiConverterString.write(value._values[0], buf)
        if isinstance(value, UniError.PocketOption):
            buf.write_i32(2)
            _UniffiFfiConverterString.write(value._values[0], buf)
        if isinstance(value, UniError.Uuid):
            buf.write_i32(3)
            _UniffiFfiConverterString.write(value._values[0], buf)
        if isinstance(value, UniError.Validator):
            buf.write_i32(4)
            _UniffiFfiConverterString.write(value._values[0], buf)

class _UniffiFfiConverterSequenceTypeAsset(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeAsset.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeAsset.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeAsset.read(buf) for i in range(count)
        ]

class _UniffiFfiConverterOptionalSequenceTypeAsset(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterSequenceTypeAsset.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterSequenceTypeAsset.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterSequenceTypeAsset.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")


class ValidatorProtocol(typing.Protocol):
    """
    Validator for filtering WebSocket messages.

    Provides various methods to validate messages using different strategies
    like regex matching, prefix/suffix checking, and logical combinations.
"""
    
    def check(self, message: str) -> bool:
        """
        Checks if a message matches this validator's conditions.

        # Arguments

        * `message` - String to validate

        # Returns

        True if message matches the validator's conditions, False otherwise
"""
        raise NotImplementedError

class Validator(ValidatorProtocol):
    """
    Validator for filtering WebSocket messages.

    Provides various methods to validate messages using different strategies
    like regex matching, prefix/suffix checking, and logical combinations.
"""
    
    _handle: ctypes.c_uint64
    @classmethod
    def all(cls, validators: typing.List[Validator]) -> Validator:
        """
        Creates a validator that requires all input validators to match.

        # Arguments

        * `validators` - List of validators that all must match

        # Examples

        ## Python
        ```python
        # Match messages that start with "Hello" and end with "World"
        v = Validator.all([
        Validator.starts_with("Hello"),
        Validator.ends_with("World")
        ])
        assert v.check("Hello Beautiful World") == True
        assert v.check("Hello Beautiful") == False
        ```
"""
        
        _UniffiFfiConverterSequenceTypeValidator.check_lower(validators)
        _uniffi_lowered_args = (
            _UniffiFfiConverterSequenceTypeValidator.lower(validators),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeValidator.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_binary_options_tools_uni_fn_constructor_validator_all,
            *_uniffi_lowered_args,
        )
        return cls._uniffi_make_instance(_uniffi_ffi_result)
    @classmethod
    def any(cls, validators: typing.List[Validator]) -> Validator:
        """
        Creates a validator that requires at least one input validator to match.

        # Arguments

        * `validators` - List of validators where at least one must match

        # Examples

        ## Python
        ```python
        # Match messages containing either "success" or "completed"
        v = Validator.any([
        Validator.contains("success"),
        Validator.contains("completed")
        ])
        assert v.check("operation successful") == True
        assert v.check("task completed") == True
        assert v.check("in progress") == False
        ```
"""
        
        _UniffiFfiConverterSequenceTypeValidator.check_lower(validators)
        _uniffi_lowered_args = (
            _UniffiFfiConverterSequenceTypeValidator.lower(validators),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeValidator.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_binary_options_tools_uni_fn_constructor_validator_any,
            *_uniffi_lowered_args,
        )
        return cls._uniffi_make_instance(_uniffi_ffi_result)
    @classmethod
    def contains(cls, substring: str) -> Validator:
        """
        Creates a validator that checks if messages contain a specific substring.

        # Arguments

        * `substring` - String that should be present in messages
"""
        
        _UniffiFfiConverterString.check_lower(substring)
        _uniffi_lowered_args = (
            _UniffiFfiConverterString.lower(substring),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeValidator.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_binary_options_tools_uni_fn_constructor_validator_contains,
            *_uniffi_lowered_args,
        )
        return cls._uniffi_make_instance(_uniffi_ffi_result)
    @classmethod
    def ends_with(cls, suffix: str) -> Validator:
        """
        Creates a validator that checks if messages end with a specific suffix.

        # Arguments

        * `suffix` - String that messages should end with
"""
        
        _UniffiFfiConverterString.check_lower(suffix)
        _uniffi_lowered_args = (
            _UniffiFfiConverterString.lower(suffix),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeValidator.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_binary_options_tools_uni_fn_constructor_validator_ends_with,
            *_uniffi_lowered_args,
        )
        return cls._uniffi_make_instance(_uniffi_ffi_result)
    @classmethod
    def ne(cls, validator: Validator) -> Validator:
        """
        Creates a validator that negates another validator's result.

        # Arguments

        * `validator` - Validator whose result should be negated

        # Examples

        ## Python
        ```python
        # Match messages that don't contain "error"
        v = Validator.ne(Validator.contains("error"))
        assert v.check("success message") == True
        assert v.check("error occurred") == False
        ```
"""
        
        _UniffiFfiConverterTypeValidator.check_lower(validator)
        _uniffi_lowered_args = (
            _UniffiFfiConverterTypeValidator.lower(validator),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeValidator.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_binary_options_tools_uni_fn_constructor_validator_ne,
            *_uniffi_lowered_args,
        )
        return cls._uniffi_make_instance(_uniffi_ffi_result)
    def __init__(self, ):
        """
        Creates a default validator that accepts all messages.
"""
        _uniffi_lowered_args = (
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeValidator.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_binary_options_tools_uni_fn_constructor_validator_new,
            *_uniffi_lowered_args,
        )
        self._handle = _uniffi_ffi_result
    @classmethod
    def regex(cls, pattern: str) -> Validator:
        """
        Creates a validator that uses regex pattern matching.

        # Arguments

        * `pattern` - Regular expression pattern

        # Examples

        ## Python
        ```python
        # Match messages starting with a number
        validator = Validator.regex(r"^\d+")
        assert validator.check("123 message") == True
        assert validator.check("abc") == False
        ```
"""
        
        _UniffiFfiConverterString.check_lower(pattern)
        _uniffi_lowered_args = (
            _UniffiFfiConverterString.lower(pattern),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeValidator.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeUniError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_binary_options_tools_uni_fn_constructor_validator_regex,
            *_uniffi_lowered_args,
        )
        return cls._uniffi_make_instance(_uniffi_ffi_result)
    @classmethod
    def starts_with(cls, prefix: str) -> Validator:
        """
        Creates a validator that checks if messages start with a specific prefix.

        # Arguments

        * `prefix` - String that messages should start with
"""
        
        _UniffiFfiConverterString.check_lower(prefix)
        _uniffi_lowered_args = (
            _UniffiFfiConverterString.lower(prefix),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeValidator.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_binary_options_tools_uni_fn_constructor_validator_starts_with,
            *_uniffi_lowered_args,
        )
        return cls._uniffi_make_instance(_uniffi_ffi_result)

    def __del__(self):
        # In case of partial initialization of instances.
        handle = getattr(self, "_handle", None)
        if handle is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_binary_options_tools_uni_fn_free_validator, handle)

    def _uniffi_clone_handle(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_binary_options_tools_uni_fn_clone_validator, self._handle)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _uniffi_make_instance(cls, handle):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required handle.
        inst = cls.__new__(cls)
        inst._handle = handle
        return inst
    def check(self, message: str) -> bool:
        """
        Checks if a message matches this validator's conditions.

        # Arguments

        * `message` - String to validate

        # Returns

        True if message matches the validator's conditions, False otherwise
"""
        
        _UniffiFfiConverterString.check_lower(message)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(message),
        )
        _uniffi_lift_return = _UniffiFfiConverterBoolean.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_binary_options_tools_uni_fn_method_validator_check,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)





class _UniffiFfiConverterTypeValidator:
    @staticmethod
    def lift(value: int) -> Validator:
        return Validator._uniffi_make_instance(value)

    @staticmethod
    def check_lower(value: Validator):
        if not isinstance(value, Validator):
            raise TypeError("Expected Validator instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Validator) -> ctypes.c_uint64:
        return value._uniffi_clone_handle()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer) -> Validator:
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw handle value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Validator, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))

class _UniffiFfiConverterBytes(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative byte string length")
        return buf.read(size)

    @staticmethod
    def check_lower(value):
        try:
            memoryview(value)
        except TypeError:
            raise TypeError("a bytes-like object is required, not {!r}".format(type(value).__name__))

    @staticmethod
    def write(value, buf):
        buf.write_i32(len(value))
        buf.write(value)


class RawHandlerProtocol(typing.Protocol):
    """
    Handler for advanced raw WebSocket message operations.

    Provides low-level access to send messages and receive filtered responses
    based on a validator. Each handler maintains its own message stream.
"""
    
    async def send_and_wait(self, message: str) -> str:
        """
        Send a message and wait for the next matching response.

        # Arguments

        * `message` - Message to send

        # Returns

        The first response that matches this handler's validator

        # Examples

        ## Python
        ```python
        response = await handler.send_and_wait('42["getBalance"]')
        data = json.loads(response)
        ```
"""
        raise NotImplementedError
    async def send_binary(self, data: bytes) -> None:
        """
        Send a binary message through this handler.

        # Arguments

        * `data` - Binary data to send

        # Examples

        ## Python
        ```python
        await handler.send_binary(b'\\x00\\x01\\x02')
        ```
"""
        raise NotImplementedError
    async def send_text(self, message: str) -> None:
        """
        Send a text message through this handler.

        # Arguments

        * `message` - Text message to send

        # Examples

        ## Python
        ```python
        await handler.send_text('42["ping"]')
        ```
"""
        raise NotImplementedError
    async def wait_next(self, ) -> str:
        """
        Wait for the next message that matches this handler's validator.

        # Returns

        The next matching message

        # Examples

        ## Python
        ```python
        message = await handler.wait_next()
        print(f"Received: {message}")
        ```
"""
        raise NotImplementedError

class RawHandler(RawHandlerProtocol):
    """
    Handler for advanced raw WebSocket message operations.

    Provides low-level access to send messages and receive filtered responses
    based on a validator. Each handler maintains its own message stream.
"""
    
    _handle: ctypes.c_uint64
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        handle = getattr(self, "_handle", None)
        if handle is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_binary_options_tools_uni_fn_free_rawhandler, handle)

    def _uniffi_clone_handle(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_binary_options_tools_uni_fn_clone_rawhandler, self._handle)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _uniffi_make_instance(cls, handle):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required handle.
        inst = cls.__new__(cls)
        inst._handle = handle
        return inst
    async def send_and_wait(self, message: str) -> str:
        """
        Send a message and wait for the next matching response.

        # Arguments

        * `message` - Message to send

        # Returns

        The first response that matches this handler's validator

        # Examples

        ## Python
        ```python
        response = await handler.send_and_wait('42["getBalance"]')
        data = json.loads(response)
        ```
"""
        
        _UniffiFfiConverterString.check_lower(message)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(message),
        )
        _uniffi_lift_return = _UniffiFfiConverterString.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeUniError
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_binary_options_tools_uni_fn_method_rawhandler_send_and_wait(*_uniffi_lowered_args),
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_free_rust_buffer,
            _uniffi_lift_return,
            _uniffi_error_converter,
        )
    async def send_binary(self, data: bytes) -> None:
        """
        Send a binary message through this handler.

        # Arguments

        * `data` - Binary data to send

        # Examples

        ## Python
        ```python
        await handler.send_binary(b'\\x00\\x01\\x02')
        ```
"""
        
        _UniffiFfiConverterBytes.check_lower(data)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterBytes.lower(data),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = _UniffiFfiConverterTypeUniError
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_binary_options_tools_uni_fn_method_rawhandler_send_binary(*_uniffi_lowered_args),
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_void,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_void,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_free_void,
            _uniffi_lift_return,
            _uniffi_error_converter,
        )
    async def send_text(self, message: str) -> None:
        """
        Send a text message through this handler.

        # Arguments

        * `message` - Text message to send

        # Examples

        ## Python
        ```python
        await handler.send_text('42["ping"]')
        ```
"""
        
        _UniffiFfiConverterString.check_lower(message)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(message),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = _UniffiFfiConverterTypeUniError
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_binary_options_tools_uni_fn_method_rawhandler_send_text(*_uniffi_lowered_args),
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_void,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_void,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_free_void,
            _uniffi_lift_return,
            _uniffi_error_converter,
        )
    async def wait_next(self, ) -> str:
        """
        Wait for the next message that matches this handler's validator.

        # Returns

        The next matching message

        # Examples

        ## Python
        ```python
        message = await handler.wait_next()
        print(f"Received: {message}")
        ```
"""
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = _UniffiFfiConverterString.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeUniError
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_binary_options_tools_uni_fn_method_rawhandler_wait_next(*_uniffi_lowered_args),
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_free_rust_buffer,
            _uniffi_lift_return,
            _uniffi_error_converter,
        )





class _UniffiFfiConverterTypeRawHandler:
    @staticmethod
    def lift(value: int) -> RawHandler:
        return RawHandler._uniffi_make_instance(value)

    @staticmethod
    def check_lower(value: RawHandler):
        if not isinstance(value, RawHandler):
            raise TypeError("Expected RawHandler instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: RawHandler) -> ctypes.c_uint64:
        return value._uniffi_clone_handle()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer) -> RawHandler:
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw handle value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: RawHandler, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))

class _UniffiFfiConverterSequenceTypeCandle(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeCandle.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeCandle.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeCandle.read(buf) for i in range(count)
        ]

class _UniffiFfiConverterSequenceTypeDeal(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeDeal.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeDeal.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeDeal.read(buf) for i in range(count)
        ]


class SubscriptionStreamProtocol(typing.Protocol):
    """
    Represents a stream of subscription data.

    This object is returned by the `subscribe` method on the `PocketOption` client.
    It allows you to receive real-time data, such as candles, for a specific asset.

    # Rationale

    Since UniFFI does not support streams directly, this wrapper provides a way to
    consume the stream by repeatedly calling the `next` method.
"""
    
    async def next(self, ) -> Candle:
        """
        Retrieves the next item from the stream.

        This method should be called in a loop to consume the data from the stream.
        It will return `None` when the stream is closed.

        # Returns

        An optional `Candle` object. It will be `None` if the stream has finished.

        # Examples

        ## Python
        ```python
        import asyncio

        async def main():
        # ... (get api object)
        stream = await api.subscribe("EURUSD_otc", 5)
        while True:
        candle = await stream.next()
        if candle is None:
        break
        print(f"New candle: {candle}")

        asyncio.run(main())
        ```

        ## Swift
        ```swift
        func subscribe() async {
        // ... (get api object)
        let stream = try! await api.subscribe(asset: "EURUSD_otc", durationSecs: 5)
        while let candle = try! await stream.next() {
        print("New candle: \(candle)")
        }
        }
        ```
"""
        raise NotImplementedError

class SubscriptionStream(SubscriptionStreamProtocol):
    """
    Represents a stream of subscription data.

    This object is returned by the `subscribe` method on the `PocketOption` client.
    It allows you to receive real-time data, such as candles, for a specific asset.

    # Rationale

    Since UniFFI does not support streams directly, this wrapper provides a way to
    consume the stream by repeatedly calling the `next` method.
"""
    
    _handle: ctypes.c_uint64
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        handle = getattr(self, "_handle", None)
        if handle is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_binary_options_tools_uni_fn_free_subscriptionstream, handle)

    def _uniffi_clone_handle(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_binary_options_tools_uni_fn_clone_subscriptionstream, self._handle)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _uniffi_make_instance(cls, handle):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required handle.
        inst = cls.__new__(cls)
        inst._handle = handle
        return inst
    async def next(self, ) -> Candle:
        """
        Retrieves the next item from the stream.

        This method should be called in a loop to consume the data from the stream.
        It will return `None` when the stream is closed.

        # Returns

        An optional `Candle` object. It will be `None` if the stream has finished.

        # Examples

        ## Python
        ```python
        import asyncio

        async def main():
        # ... (get api object)
        stream = await api.subscribe("EURUSD_otc", 5)
        while True:
        candle = await stream.next()
        if candle is None:
        break
        print(f"New candle: {candle}")

        asyncio.run(main())
        ```

        ## Swift
        ```swift
        func subscribe() async {
        // ... (get api object)
        let stream = try! await api.subscribe(asset: "EURUSD_otc", durationSecs: 5)
        while let candle = try! await stream.next() {
        print("New candle: \(candle)")
        }
        }
        ```
"""
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeCandle.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeUniError
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_binary_options_tools_uni_fn_method_subscriptionstream_next(*_uniffi_lowered_args),
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_free_rust_buffer,
            _uniffi_lift_return,
            _uniffi_error_converter,
        )





class _UniffiFfiConverterTypeSubscriptionStream:
    @staticmethod
    def lift(value: int) -> SubscriptionStream:
        return SubscriptionStream._uniffi_make_instance(value)

    @staticmethod
    def check_lower(value: SubscriptionStream):
        if not isinstance(value, SubscriptionStream):
            raise TypeError("Expected SubscriptionStream instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: SubscriptionStream) -> ctypes.c_uint64:
        return value._uniffi_clone_handle()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer) -> SubscriptionStream:
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw handle value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SubscriptionStream, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))


class PocketOptionProtocol(typing.Protocol):
    """
    The main client for interacting with the PocketOption platform.

    This object provides all the functionality needed to connect to PocketOption,
    place trades, get account information, and subscribe to market data.

    It is the primary entry point for using this library.

    # Rationale

    This struct wraps the underlying `binary_options_tools::pocketoption::PocketOption` client,
    exposing its functionality in a way that is compatible with UniFFI for creating
    multi-language bindings.
"""
    
    async def assets(self, ) -> typing.Optional[typing.List[Asset]]:
        """
        Gets the list of available assets for trading.

        # Returns

        A list of `Asset` objects, or `None` if the assets have not been loaded yet.
"""
        raise NotImplementedError
    async def balance(self, ) -> float:
        """
        Gets the current balance of the account.

        This method retrieves the current trading balance from the client's state.

        # Returns

        The current balance as a floating-point number.
"""
        raise NotImplementedError
    async def buy(self, asset: str,time: int,amount: float) -> Deal:
        """
        Places a "Call" (buy) trade.

        This is a convenience method that calls `trade` with `Action.Call`.
"""
        raise NotImplementedError
    async def clear_closed_deals(self, ) -> None:
        """
        Clears the list of closed deals from the client's state.
"""
        raise NotImplementedError
    async def create_raw_handler(self, validator: Validator,keep_alive: typing.Optional[str]) -> RawHandler:
        """
        Creates a raw handler for advanced WebSocket message operations.

        This allows you to send custom messages and receive filtered responses
        based on a validator. Useful for implementing custom protocols or
        accessing features not directly exposed by the API.

        # Arguments

        * `validator` - Validator to filter incoming messages
        * `keep_alive` - Optional message to send on reconnect (e.g., for re-subscribing)

        # Returns

        A `RawHandler` object for sending and receiving messages

        # Examples

        ## Python
        ```python
        # Create a validator for balance updates
        validator = Validator.contains('"balance"')
        handler = await client.create_raw_handler(validator, None)

        # Send a custom message
        await handler.send_text('42["getBalance"]')

        # Wait for response
        response = await handler.wait_next()
        print(f"Received: {response}")
        ```
"""
        raise NotImplementedError
    async def get_candles(self, asset: str,period: int,offset: int) -> typing.List[Candle]:
        """
        Gets historical candle data for a specific asset.
"""
        raise NotImplementedError
    async def get_candles_advanced(self, asset: str,period: int,time: int,offset: int) -> typing.List[Candle]:
        """
        Gets historical candle data for a specific asset with advanced parameters.
"""
        raise NotImplementedError
    async def get_closed_deals(self, ) -> typing.List[Deal]:
        """
        Gets the list of currently closed deals.
"""
        raise NotImplementedError
    async def get_opened_deals(self, ) -> typing.List[Deal]:
        """
        Gets the list of currently opened deals.
"""
        raise NotImplementedError
    async def history(self, asset: str,period: int) -> typing.List[Candle]:
        """
        Gets historical candle data for a specific asset and period.
"""
        raise NotImplementedError
    def is_demo(self, ) -> bool:
        """
        Checks if the current session is a demo account.

        # Returns

        `true` if the account is a demo account, `false` otherwise.
"""
        raise NotImplementedError
    async def payout(self, asset: str) -> typing.Optional[float]:
        """
        Gets the payout percentage for a specific asset.

        Returns the profit percentage you'll receive if a trade on this asset wins.
        For example, 0.8 means 80% profit (if you bet $1, you get $1.80 back).

        # Arguments

        * `asset` - The symbol of the asset (e.g., "EURUSD_otc")

        # Returns

        The payout percentage as a float, or None if the asset is not available

        # Examples

        ## Python
        ```python
        payout = await client.payout("EURUSD_otc")
        if payout:
        print(f"Payout: {payout * 100}%")
        # Example output: "Payout: 80.0%"
        else:
        print("Asset not available")
        ```
"""
        raise NotImplementedError
    async def reconnect(self, ) -> None:
        """
        Disconnects and reconnects the client.
"""
        raise NotImplementedError
    async def result(self, id: str) -> Deal:
        """
        Checks the result of a trade by its ID.

        # Arguments

        * `id` - The ID of the trade to check (as a string).

        # Returns

        A `Deal` object representing the completed trade.
"""
        raise NotImplementedError
    async def result_with_timeout(self, id: str,timeout_secs: int) -> Deal:
        """
        Checks the result of a trade by its ID with a timeout.

        # Arguments

        * `id` - The ID of the trade to check (as a string).
        * `timeout_secs` - The maximum time to wait for the result in seconds.

        # Returns

        A `Deal` object representing the completed trade.
"""
        raise NotImplementedError
    async def sell(self, asset: str,time: int,amount: float) -> Deal:
        """
        Places a "Put" (sell) trade.

        This is a convenience method that calls `trade` with `Action.Put`.
"""
        raise NotImplementedError
    async def server_time(self, ) -> int:
        """
        Gets the current server time as a Unix timestamp.
"""
        raise NotImplementedError
    async def shutdown(self, ) -> None:
        """
        Shuts down the client and stops all background tasks.

        This method should be called when you are finished with the client
        to ensure a graceful shutdown.
"""
        raise NotImplementedError
    async def subscribe(self, asset: str,duration_secs: int) -> SubscriptionStream:
        """
        Subscribes to real-time candle data for a specific asset.

        # Arguments

        * `asset` - The symbol of the asset to subscribe to.
        * `duration_secs` - The duration of each candle in seconds.

        # Returns

        A `SubscriptionStream` object that can be used to receive candle data.
"""
        raise NotImplementedError
    async def trade(self, asset: str,action: Action,time: int,amount: float) -> Deal:
        """
        Places a trade.

        This is the core method for executing trades.

        # Arguments

        * `asset` - The symbol of the asset to trade (e.g., "EURUSD_otc").
        * `action` - The direction of the trade (`Action.Call` or `Action.Put`).
        * `time` - The duration of the trade in seconds.
        * `amount` - The amount to trade.

        # Returns

        A `Deal` object representing the completed trade.
"""
        raise NotImplementedError
    async def unsubscribe(self, asset: str) -> None:
        """
        Unsubscribes from real-time candle data for a specific asset.
"""
        raise NotImplementedError

class PocketOption(PocketOptionProtocol):
    """
    The main client for interacting with the PocketOption platform.

    This object provides all the functionality needed to connect to PocketOption,
    place trades, get account information, and subscribe to market data.

    It is the primary entry point for using this library.

    # Rationale

    This struct wraps the underlying `binary_options_tools::pocketoption::PocketOption` client,
    exposing its functionality in a way that is compatible with UniFFI for creating
    multi-language bindings.
"""
    
    _handle: ctypes.c_uint64
    @classmethod
    async def init(cls, ssid: str) -> PocketOption:
        """
        Creates a new instance of the PocketOption client.

        This is the primary constructor for the client. It requires a session ID (ssid)
        to authenticate with the PocketOption servers.

        # Arguments

        * `ssid` - The session ID for your PocketOption account.

        # Examples

        ## Python
        ```python
        import asyncio
        from binaryoptionstoolsuni import PocketOption

        async def main():
        ssid = "YOUR_SESSION_ID"
        api = await PocketOption.init(ssid)
        balance = await api.balance()
        print(f"Balance: {balance}")

        asyncio.run(main())
        ```
"""
        
        _UniffiFfiConverterString.check_lower(ssid)
        _uniffi_lowered_args = (
            _UniffiFfiConverterString.lower(ssid),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypePocketOption.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeUniError
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_binary_options_tools_uni_fn_constructor_pocketoption_init(*_uniffi_lowered_args),
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_u64,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_u64,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_free_u64,
            _uniffi_lift_return,
            _uniffi_error_converter,
        )
    def __init__(self, *args, **kw):
        raise ValueError("async constructors not supported.")
    @classmethod
    async def new_with_url(cls, ssid: str,url: str) -> PocketOption:
        """
        Creates a new instance of the PocketOption client with a custom WebSocket URL.

        This constructor is useful for connecting to different PocketOption servers,
        for example, in different regions.

        # Arguments

        * `ssid` - The session ID for your PocketOption account.
        * `url` - The custom WebSocket URL to connect to.
"""
        
        _UniffiFfiConverterString.check_lower(ssid)
        
        _UniffiFfiConverterString.check_lower(url)
        _uniffi_lowered_args = (
            _UniffiFfiConverterString.lower(ssid),
            _UniffiFfiConverterString.lower(url),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypePocketOption.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeUniError
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_binary_options_tools_uni_fn_constructor_pocketoption_new_with_url(*_uniffi_lowered_args),
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_u64,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_u64,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_free_u64,
            _uniffi_lift_return,
            _uniffi_error_converter,
        )

    def __del__(self):
        # In case of partial initialization of instances.
        handle = getattr(self, "_handle", None)
        if handle is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_binary_options_tools_uni_fn_free_pocketoption, handle)

    def _uniffi_clone_handle(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_binary_options_tools_uni_fn_clone_pocketoption, self._handle)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _uniffi_make_instance(cls, handle):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required handle.
        inst = cls.__new__(cls)
        inst._handle = handle
        return inst
    async def assets(self, ) -> typing.Optional[typing.List[Asset]]:
        """
        Gets the list of available assets for trading.

        # Returns

        A list of `Asset` objects, or `None` if the assets have not been loaded yet.
"""
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = _UniffiFfiConverterOptionalSequenceTypeAsset.lift
        _uniffi_error_converter = None
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_assets(*_uniffi_lowered_args),
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_free_rust_buffer,
            _uniffi_lift_return,
            _uniffi_error_converter,
        )
    async def balance(self, ) -> float:
        """
        Gets the current balance of the account.

        This method retrieves the current trading balance from the client's state.

        # Returns

        The current balance as a floating-point number.
"""
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = _UniffiFfiConverterFloat64.lift
        _uniffi_error_converter = None
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_balance(*_uniffi_lowered_args),
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_f64,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_f64,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_free_f64,
            _uniffi_lift_return,
            _uniffi_error_converter,
        )
    async def buy(self, asset: str,time: int,amount: float) -> Deal:
        """
        Places a "Call" (buy) trade.

        This is a convenience method that calls `trade` with `Action.Call`.
"""
        
        _UniffiFfiConverterString.check_lower(asset)
        
        _UniffiFfiConverterUInt32.check_lower(time)
        
        _UniffiFfiConverterFloat64.check_lower(amount)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(asset),
            _UniffiFfiConverterUInt32.lower(time),
            _UniffiFfiConverterFloat64.lower(amount),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeDeal.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeUniError
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_buy(*_uniffi_lowered_args),
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_free_rust_buffer,
            _uniffi_lift_return,
            _uniffi_error_converter,
        )
    async def clear_closed_deals(self, ) -> None:
        """
        Clears the list of closed deals from the client's state.
"""
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = None
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_clear_closed_deals(*_uniffi_lowered_args),
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_void,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_void,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_free_void,
            _uniffi_lift_return,
            _uniffi_error_converter,
        )
    async def create_raw_handler(self, validator: Validator,keep_alive: typing.Optional[str]) -> RawHandler:
        """
        Creates a raw handler for advanced WebSocket message operations.

        This allows you to send custom messages and receive filtered responses
        based on a validator. Useful for implementing custom protocols or
        accessing features not directly exposed by the API.

        # Arguments

        * `validator` - Validator to filter incoming messages
        * `keep_alive` - Optional message to send on reconnect (e.g., for re-subscribing)

        # Returns

        A `RawHandler` object for sending and receiving messages

        # Examples

        ## Python
        ```python
        # Create a validator for balance updates
        validator = Validator.contains('"balance"')
        handler = await client.create_raw_handler(validator, None)

        # Send a custom message
        await handler.send_text('42["getBalance"]')

        # Wait for response
        response = await handler.wait_next()
        print(f"Received: {response}")
        ```
"""
        
        _UniffiFfiConverterTypeValidator.check_lower(validator)
        
        _UniffiFfiConverterOptionalString.check_lower(keep_alive)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterTypeValidator.lower(validator),
            _UniffiFfiConverterOptionalString.lower(keep_alive),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeRawHandler.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeUniError
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_create_raw_handler(*_uniffi_lowered_args),
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_u64,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_u64,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_free_u64,
            _uniffi_lift_return,
            _uniffi_error_converter,
        )
    async def get_candles(self, asset: str,period: int,offset: int) -> typing.List[Candle]:
        """
        Gets historical candle data for a specific asset.
"""
        
        _UniffiFfiConverterString.check_lower(asset)
        
        _UniffiFfiConverterInt64.check_lower(period)
        
        _UniffiFfiConverterInt64.check_lower(offset)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(asset),
            _UniffiFfiConverterInt64.lower(period),
            _UniffiFfiConverterInt64.lower(offset),
        )
        _uniffi_lift_return = _UniffiFfiConverterSequenceTypeCandle.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeUniError
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_get_candles(*_uniffi_lowered_args),
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_free_rust_buffer,
            _uniffi_lift_return,
            _uniffi_error_converter,
        )
    async def get_candles_advanced(self, asset: str,period: int,time: int,offset: int) -> typing.List[Candle]:
        """
        Gets historical candle data for a specific asset with advanced parameters.
"""
        
        _UniffiFfiConverterString.check_lower(asset)
        
        _UniffiFfiConverterInt64.check_lower(period)
        
        _UniffiFfiConverterInt64.check_lower(time)
        
        _UniffiFfiConverterInt64.check_lower(offset)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(asset),
            _UniffiFfiConverterInt64.lower(period),
            _UniffiFfiConverterInt64.lower(time),
            _UniffiFfiConverterInt64.lower(offset),
        )
        _uniffi_lift_return = _UniffiFfiConverterSequenceTypeCandle.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeUniError
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_get_candles_advanced(*_uniffi_lowered_args),
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_free_rust_buffer,
            _uniffi_lift_return,
            _uniffi_error_converter,
        )
    async def get_closed_deals(self, ) -> typing.List[Deal]:
        """
        Gets the list of currently closed deals.
"""
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = _UniffiFfiConverterSequenceTypeDeal.lift
        _uniffi_error_converter = None
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_get_closed_deals(*_uniffi_lowered_args),
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_free_rust_buffer,
            _uniffi_lift_return,
            _uniffi_error_converter,
        )
    async def get_opened_deals(self, ) -> typing.List[Deal]:
        """
        Gets the list of currently opened deals.
"""
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = _UniffiFfiConverterSequenceTypeDeal.lift
        _uniffi_error_converter = None
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_get_opened_deals(*_uniffi_lowered_args),
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_free_rust_buffer,
            _uniffi_lift_return,
            _uniffi_error_converter,
        )
    async def history(self, asset: str,period: int) -> typing.List[Candle]:
        """
        Gets historical candle data for a specific asset and period.
"""
        
        _UniffiFfiConverterString.check_lower(asset)
        
        _UniffiFfiConverterUInt32.check_lower(period)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(asset),
            _UniffiFfiConverterUInt32.lower(period),
        )
        _uniffi_lift_return = _UniffiFfiConverterSequenceTypeCandle.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeUniError
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_history(*_uniffi_lowered_args),
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_free_rust_buffer,
            _uniffi_lift_return,
            _uniffi_error_converter,
        )
    def is_demo(self, ) -> bool:
        """
        Checks if the current session is a demo account.

        # Returns

        `true` if the account is a demo account, `false` otherwise.
"""
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = _UniffiFfiConverterBoolean.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_is_demo,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    async def payout(self, asset: str) -> typing.Optional[float]:
        """
        Gets the payout percentage for a specific asset.

        Returns the profit percentage you'll receive if a trade on this asset wins.
        For example, 0.8 means 80% profit (if you bet $1, you get $1.80 back).

        # Arguments

        * `asset` - The symbol of the asset (e.g., "EURUSD_otc")

        # Returns

        The payout percentage as a float, or None if the asset is not available

        # Examples

        ## Python
        ```python
        payout = await client.payout("EURUSD_otc")
        if payout:
        print(f"Payout: {payout * 100}%")
        # Example output: "Payout: 80.0%"
        else:
        print("Asset not available")
        ```
"""
        
        _UniffiFfiConverterString.check_lower(asset)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(asset),
        )
        _uniffi_lift_return = _UniffiFfiConverterOptionalFloat64.lift
        _uniffi_error_converter = None
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_payout(*_uniffi_lowered_args),
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_free_rust_buffer,
            _uniffi_lift_return,
            _uniffi_error_converter,
        )
    async def reconnect(self, ) -> None:
        """
        Disconnects and reconnects the client.
"""
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = _UniffiFfiConverterTypeUniError
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_reconnect(*_uniffi_lowered_args),
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_void,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_void,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_free_void,
            _uniffi_lift_return,
            _uniffi_error_converter,
        )
    async def result(self, id: str) -> Deal:
        """
        Checks the result of a trade by its ID.

        # Arguments

        * `id` - The ID of the trade to check (as a string).

        # Returns

        A `Deal` object representing the completed trade.
"""
        
        _UniffiFfiConverterString.check_lower(id)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(id),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeDeal.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeUniError
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_result(*_uniffi_lowered_args),
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_free_rust_buffer,
            _uniffi_lift_return,
            _uniffi_error_converter,
        )
    async def result_with_timeout(self, id: str,timeout_secs: int) -> Deal:
        """
        Checks the result of a trade by its ID with a timeout.

        # Arguments

        * `id` - The ID of the trade to check (as a string).
        * `timeout_secs` - The maximum time to wait for the result in seconds.

        # Returns

        A `Deal` object representing the completed trade.
"""
        
        _UniffiFfiConverterString.check_lower(id)
        
        _UniffiFfiConverterUInt64.check_lower(timeout_secs)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(id),
            _UniffiFfiConverterUInt64.lower(timeout_secs),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeDeal.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeUniError
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_result_with_timeout(*_uniffi_lowered_args),
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_free_rust_buffer,
            _uniffi_lift_return,
            _uniffi_error_converter,
        )
    async def sell(self, asset: str,time: int,amount: float) -> Deal:
        """
        Places a "Put" (sell) trade.

        This is a convenience method that calls `trade` with `Action.Put`.
"""
        
        _UniffiFfiConverterString.check_lower(asset)
        
        _UniffiFfiConverterUInt32.check_lower(time)
        
        _UniffiFfiConverterFloat64.check_lower(amount)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(asset),
            _UniffiFfiConverterUInt32.lower(time),
            _UniffiFfiConverterFloat64.lower(amount),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeDeal.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeUniError
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_sell(*_uniffi_lowered_args),
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_free_rust_buffer,
            _uniffi_lift_return,
            _uniffi_error_converter,
        )
    async def server_time(self, ) -> int:
        """
        Gets the current server time as a Unix timestamp.
"""
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = _UniffiFfiConverterInt64.lift
        _uniffi_error_converter = None
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_server_time(*_uniffi_lowered_args),
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_i64,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_i64,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_free_i64,
            _uniffi_lift_return,
            _uniffi_error_converter,
        )
    async def shutdown(self, ) -> None:
        """
        Shuts down the client and stops all background tasks.

        This method should be called when you are finished with the client
        to ensure a graceful shutdown.
"""
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = _UniffiFfiConverterTypeUniError
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_shutdown(*_uniffi_lowered_args),
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_void,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_void,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_free_void,
            _uniffi_lift_return,
            _uniffi_error_converter,
        )
    async def subscribe(self, asset: str,duration_secs: int) -> SubscriptionStream:
        """
        Subscribes to real-time candle data for a specific asset.

        # Arguments

        * `asset` - The symbol of the asset to subscribe to.
        * `duration_secs` - The duration of each candle in seconds.

        # Returns

        A `SubscriptionStream` object that can be used to receive candle data.
"""
        
        _UniffiFfiConverterString.check_lower(asset)
        
        _UniffiFfiConverterUInt64.check_lower(duration_secs)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(asset),
            _UniffiFfiConverterUInt64.lower(duration_secs),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeSubscriptionStream.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeUniError
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_subscribe(*_uniffi_lowered_args),
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_u64,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_u64,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_free_u64,
            _uniffi_lift_return,
            _uniffi_error_converter,
        )
    async def trade(self, asset: str,action: Action,time: int,amount: float) -> Deal:
        """
        Places a trade.

        This is the core method for executing trades.

        # Arguments

        * `asset` - The symbol of the asset to trade (e.g., "EURUSD_otc").
        * `action` - The direction of the trade (`Action.Call` or `Action.Put`).
        * `time` - The duration of the trade in seconds.
        * `amount` - The amount to trade.

        # Returns

        A `Deal` object representing the completed trade.
"""
        
        _UniffiFfiConverterString.check_lower(asset)
        
        _UniffiFfiConverterTypeAction.check_lower(action)
        
        _UniffiFfiConverterUInt32.check_lower(time)
        
        _UniffiFfiConverterFloat64.check_lower(amount)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(asset),
            _UniffiFfiConverterTypeAction.lower(action),
            _UniffiFfiConverterUInt32.lower(time),
            _UniffiFfiConverterFloat64.lower(amount),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeDeal.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeUniError
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_trade(*_uniffi_lowered_args),
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_free_rust_buffer,
            _uniffi_lift_return,
            _uniffi_error_converter,
        )
    async def unsubscribe(self, asset: str) -> None:
        """
        Unsubscribes from real-time candle data for a specific asset.
"""
        
        _UniffiFfiConverterString.check_lower(asset)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(asset),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = _UniffiFfiConverterTypeUniError
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_binary_options_tools_uni_fn_method_pocketoption_unsubscribe(*_uniffi_lowered_args),
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_poll_void,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_complete_void,
            _UniffiLib.ffi_binary_options_tools_uni_rust_future_free_void,
            _uniffi_lift_return,
            _uniffi_error_converter,
        )





class _UniffiFfiConverterTypePocketOption:
    @staticmethod
    def lift(value: int) -> PocketOption:
        return PocketOption._uniffi_make_instance(value)

    @staticmethod
    def check_lower(value: PocketOption):
        if not isinstance(value, PocketOption):
            raise TypeError("Expected PocketOption instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: PocketOption) -> ctypes.c_uint64:
        return value._uniffi_clone_handle()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer) -> PocketOption:
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw handle value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: PocketOption, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))

class _UniffiFfiConverterUInt8(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u8"
    VALUE_MIN = 0
    VALUE_MAX = 2**8

    @staticmethod
    def read(buf):
        return buf.read_u8()

    @staticmethod
    def write(value, buf):
        buf.write_u8(value)

class _UniffiFfiConverterSequenceTypeValidator(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeValidator.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeValidator.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeValidator.read(buf) for i in range(count)
        ]

__all__ = [
    "InternalError",
    "AssetType",
    "Action",
    "UniError",
    "CandleLength",
    "Asset",
    "Candle",
    "Deal",
    "Validator",
    "ValidatorProtocol",
    "RawHandler",
    "RawHandlerProtocol",
    "SubscriptionStream",
    "SubscriptionStreamProtocol",
    "PocketOption",
    "PocketOptionProtocol",
]